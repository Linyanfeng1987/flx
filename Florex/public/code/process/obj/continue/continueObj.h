#pragma once
#include <list>
#include <map>
#include "process/obj/rateValue.h"
#include "continueValue.h"
#include "LinkedHashMap.h"
#include <memory>
#include "continueJudgeGroup.h"
#include "continueSubsection.h"
#include "continueFinder.h"

using namespace std;
// 连续有个起点A
// 连续有方向 
// 连续的判定？1回撤的幅度？

// 在一定时间段，一个方向上，连续？
// 起始点的判断？上一个的终点？那不同的阈值将决定不同的终点？
// 尝试多个阈值？ 阈值的准确性？ 
// 连续方向的切换平率？
// 如何定义方向的正确性？
// 是否分类统计？manager？ 先不设置manager试试

// 思路：
// 1. 要完成成长，记录成长过程，
// 2. 那就要知道成长的标准
// 3. 是否存在合并这一说？合并的原则？时间连续，方向连续，前者中断？合并逻辑较为困难
// 4. 还是走成长这个模拟思路较好
// 5. 成长的标准，度量队列？
// 6. 参与成员：CContinueObj：连续记录，保持，成长
//				标准对象组：对象生成，存储，切换
//				标准对象：判断起始连续，中断，成长标准（不可直接被外部访问，仅仅拿到level
//				builder：标准的集合？初始连续判断+obj生成
//				continus：多个obj的存储


class CContinueObj
{
public:
	CContinueObj(PContinueSubsection pCurSubsection, int curDir);

	void setId(long objId){this->objId = objId;}
	long getId(){ return objId;}

	emumContinueStatus isContinueGoOn(PRateValue curValue);

	list<PContinueSubsection>& getSubsections(){return subsections;}

protected:
	void curLowDown(PRateValue curValue, emumContinueStatus curContinueStatus );
	void curKeep(PRateValue curValue, emumContinueStatus curContinueStatus );

	PContinueSubsection pCurSubsection;
	PContinueSubsection pReserveSubsecton;

	PContinueFinder pFinder;
	list<PContinueSubsection> subsections;
	long objId;
	emumContinueStatus curObjStatus;
	int curDir;
};

typedef shared_ptr<CContinueObj> PContinueObj;
#define newContinueObj(T1,T2) make_shared<CContinueObj>(T1,T2)